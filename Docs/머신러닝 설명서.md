## **0) 한 줄 요약**

이 코드는 **Prophet로 섹터별 시계열을 예측**한 뒤, **잔차를 XGBoost로 보정(하이브리드)** 하고, 이를 **여러 예측 기간(2주/1개월/분기/1년)** 에 대해 반복 수행해서, 마지막에 **연도×섹터 단위로 예측 수익률/실제 수익률을 모아 통합 테이블**을 만든다.

---

### **07_Integrated_Prophet_Analysis.ipynb**

### (실험/오케스트레이션)

- 데이터 로드/전처리
- Prophet 학습/예측 실행
- 하이브리드(Prophet + XGB residual) 실험
- 멀티 호라이즌 실행(2w, 1m, 1q, 1y)
- 결과 저장, 랭킹/클러스터링(추가 모듈 사용)

**즉,** **“실험을 돌리는 본체(실행 스크립트)”** 역할.

### **multi_horizon_predictor.py**

### (재사용 가능한 파이프라인 모듈)

- 여러 horizon(기간)을 루프 돌면서
- (연도별 split 기준으로) 예측을 수행하고
- horizon별 결과를 하나의 테이블로 통합

**즉, “멀티 호라이즌 예측 결과를 표준 포맷으로 뽑는 엔진”** 역할.

---

## **2) 하이브리드 예측이 뭔지(핵심 아이디어)**

Prophet는 “추세/계절성” 같은 큰 패턴을 잘 잡지만, 현실 데이터의 미세한 오차(잔차)는 남습니다.

그래서:

1. Prophet로 1차 예측을 하고
2. 실제값 - 예측값 = residual(잔차)을 만든 다음
3. 그 residual을 XGBoost로 학습해서
4. 최종 예측 = Prophet 예측 + (XGB가 예측한 residual)

이게 하이브리드 방식

---

## **3) 노트북 로직 흐름(팀 설명용 단계별)**

### **Step A. 데이터 준비**

- 섹터별 가격/지표 데이터 준비
- (통상) 로그 변환된 타깃 **y**를 쓰는 구조

### **Step B. Prophet 기본 예측**

- 섹터별로 Prophet을 학습하고 **yhat**(예측)을 생성
- 이 결과를 원본 데이터와 합쳐 **full_feat** 같은 “특징 테이블”을 만듦

### **Step C. 잔차 생성 + XGB 피처 생성**

- resid = y_actual - yhat_prophet
- y_lag **, **rolling mean/std** 같은 시계열 피처 생성**
- horizon(예: 10거래일)별로 target을 **shift(-horizon)** 형태로 만들어 “미래 잔차”를 학습 대상으로 둠

### **Step D. 하이브리드 결합**

- XGB로 예측한 미래 residual을 Prophet 예측에 더해서 최종 예측 생성
- **이 결과가 **yhat_hybrid** 혹은 **yhat_hybrid_h** 같은 컬럼으로 저장됨**

### **Step E. 멀티 호라이즌 반복 실행**

- 2주/1개월/분기/1년 각각에 대해 위 과정을 반복
- 각 horizon별 결과를 파일/테이블로 관리

---

## **4)** **MultiHorizonPredictor**

## **(py 모듈) 로직 흐름**

### **핵심 입력**

- sector_final **: (섹터별로) **ds**, **y_actual**(로그), 그리고 예측 컬럼들(**yhat_prophet**, **yhat_hybrid...**)이 포함된 테이블**
- **predict_func**: “주어진 sector_data와 year를 받아서 예측 결과 DataFrame을 반환”하는 함수

### **실행 흐름**

1. predict_all_horizons(horizon_dict, years, sectors, ...)

   - horizon(기간)별로 반복
   - year(학습/테스트 분리 연도)별로 반복
   - sector별로 데이터를 잘라 **predict_func** 실행
   - **결과를** self.predictions[horizon][year]**에 저장**

2. build_integrated_table()

   - horizon×year×sector 결과를 모아서
   - “실제 수익률 / 예측 수익률”을 계산해 한 테이블로 합침
   - 최종 산출물: **integrated_table** (분석/랭킹/클러스터링용)

   ***

## **5) 최종 산출물**

이 파이프라인의 끝에서 얻는 건 대체로 2종

1. **horizon별 예측 결과 원본 테이블**
   - ds**, **Sector**, **y_actual**, **yhat_prophet**, **yhat_hybrid...
   - 디버깅/모델 평가용
2. **통합 테이블(integrated_table)**
   - 행: (Year, Sector, Horizon)
   - **열: **actual_return**, **pred_return**, 기타 메타**
   - 이걸로 LTR(랭킹), 클러스터링, 백테스트로 넘어감

---

## **7) “의도/확장 포인트”**

- 멀티 호라이즌 결과를 모아두면
  - “단기 강한 섹터 vs 장기 강한 섹터”가 구분되고
  - 이를 기반으로 **군집화**나 **LTR 랭킹**에 피처로 넣기 좋다.
- 즉, 단일 예측보다 **포트폴리오 의사결정**에 더 직접적으로 연결된다.

---
